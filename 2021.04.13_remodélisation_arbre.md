# Scénario 1 : consultation d'une ressource :2roues

# L'arbre est initialisé

:2roues

ids: [':2roues']
root: ':2roues'
entities: {
    :2roues: {
        id: ':2roues'
        identity: [
            {p: 'a', o: 'E32'}
            {p: 'creator', o: ':antoine'}
        ]
        predicates: []
    }
}

# On clique sur la racine

:2roues
    > a (1)
    > creator (1)
    < P140 (2)
    < P141 (3)

<!-- SPARQL : ?direction ?p ?count -->

ids: [':2roues']
root: ':2roues'
entities: {
    :2roues: {
        id: ':2roues'
        identity: [
            {p: 'a', o: 'E32'}
            {p: 'creator', o: ':antoine'}
        ]
        predicates: [
            {direction: 'o', p: 'a', count: 1 }
            {direction: 'o', p: 'creator', count: 1 }
            {direction: 'i', p: 'P140', count: 2 }
            {direction: 'i', p: 'P141', count: 3 }
        ]
    }
}

# On déplie P140

:2roues
    > a (1)
    > creator (1)
    < P140 (2)
        :04
        :09
    < P141 (3)

ids: [':2roues', ':04', ':09']
root: ':2roues'
entities: {
    :2roues: {
        id: ':2roues'
        identity: [
            {p: 'a', o: 'E32'}
            {p: 'creator', o: ':antoine'}
        ]
        predicates: [
            {direction: 'o', p: 'a', count: 1 }
            {direction: 'o', p: 'creator', count: 1 }
            {direction: 'i', p: 'P140', count: 2, resources: [{type: 'uri, value: ':04'}, {type: 'uri, value: ':09'}] }
            {direction: 'i', p: 'P141', count: 3 }
        ]
    }
    ':04': {
        id: ':04'
        identity: [
            { p: 'a', o: 'E13' }
            { p: 'P14', o ':antoine' }
        ]
    }
    ':09': {
        id: ':09'
        identity: [
            { p: 'a', o: 'E13' }
            { p: 'P14', o ':antoine' }
        ]
    }
}

# On déplie :04

:2roues
    > a (1)
    > creator (1)
    < P140 (2)
        :04
            > a (1)
            > P14 (1)
            > P140 (1)
            > P177 (1)
            > P141 (1)
        :09
    < P141 (3)

ids: [':2roues', ':04', ':09']
root: ':2roues'
entities: {
    :2roues: {
        id: ':2roues'
        identity: [
            {p: 'a', o: 'E32'}
            {p: 'creator', o: ':antoine'}
        ]
        predicates: [
            {direction: 'o', p: 'a', count: 1 }
            {direction: 'o', p: 'creator', count: 1 }
            {direction: 'i', p: 'P140', count: 2, resources: [{type: 'uri, value: ':04'}, {type: 'uri, value: ':09'}] }
            {direction: 'i', p: 'P141', count: 3 }
        ]
    },
    :04: {
        id: ':04',
        identity: [
            { p: 'a', o: 'E13' }
            { p: 'P14', o ':antoine' }
        ]
        predicates: [
            {direction: 'o', p: 'a', count: 1 }
            {direction: 'o', p: 'P14', count: 1 }
            {direction: 'o', p: 'P140', count: 1 }
            {direction: 'o', p: 'P177', count: 1 }
            {direction: 'o', p: 'P141', count: 1 }
        ]
    }
    ':09': {
        id: ':09'
        identity: [
            { p: 'a', o: 'E13' }
            { p: 'P14', o ':antoine' }
        ]
    }
}

# Problèmes potentiels

## graphe cyclique ?

r0 p0 r0

On veut pouvoir développer plusieurs fois un nœud si on veut, ce n'est pas acceptable de dire "non je ne veux pas développer ce nœud car il a été affiché ailleurs".
L'arbre repose sur une state des nœuds dépliés.

r0
    p0 (1)
        > r0 -> on déplie CE nœud que si il a été cliqué, /!\ r0 != r0/p0/r0

Comment donner une bonne key aux objets visuels ? -> pas en sérialisant les triplets, mais en prenant le chemin visuel par rapport à la racine.

1. r0
2. clic sur r0
3. r0
    > p0 (1)
4. clic sur r0/p0 (c'est sa key react)
5. Le PTI de p0 va instancier le RTI de r0 avec la key r0/p0/r0
6. Le RTI de r0 (de key r0/p0/r0) va chercher r0 dans la store avec un selector, mais n'affiche pas les enfants car r0/p0/r0 n'a jamais été cliqué
7. Chaque RTI reçoit en props la liste des keys des nœuds cliqués, pour brider l'instanciation des PTI dont le S n'aurait pas été cliqué.

Comme cette liste de nœuds cliqués dans un arbre donné peut être mise à jour par n'importe quel enfant visuel, qqsoit non niveau de profondeur, il faut trouver une manière de maintenir un état synchro de cette state.

## type ? et pour les littéraux ?

✔

## nœud avec enfant ou pas (feuille ou nœud) ?

Notre arbre n'a jamais de feuilles
Il faut coder un LiteralTreeItem (ce sont les seules vraies feuilles). Un literal peut avoir une langue et un type de données XSD.

# Changement de racine

:4roues
    > a (1)
    > creator (1)
    < P140 (2)
    < P141 (3)
        :27
            > a (1)
            > P14 (1)
            > 140 (1)
                :voc2    <= choisir cette ressource comme nouvelle racine de l'arbre, et naviguer vers /id/:voc2
            > 177 (1)
                P71
            > 141 (1)
                :4roues

# Exemple de state minimale pour tester le développement avec un graphe cyclique

<!-- <R1> <nimportequelprédicat> <R1> -->

ids: ['R1']
root: 'R1'
entities: {
    R1: {
        id: 'R1'
        identity: [
        ]
        predicates: [
            {direction: 'o', p: 'nimportequelprédicat', count: 1, resources: [{type: 'uri, value: 'R1'}] }
        ]
    }
}
